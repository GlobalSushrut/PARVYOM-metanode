use serde::{Deserialize, Serialize};
use rust_decimal::Decimal;
use chrono::{DateTime, Utc};
use std::collections::HashMap;
use anyhow::Result;
use thiserror::Error;
use crate::autonomous_economy::CoinType;

/// Work proof system ensuring coins earn value only through real work
/// All coins start at zero value and must prove work to earn value

/// Types of real work that can earn coin value
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum WorkType {
    /// BPI wallet runtime rent payment
    BpiRuntimeRent {
        wallet_id: String,
        session_duration_hours: u32,
        rent_rate_per_hour: Decimal,
    },
    /// BPI transaction gas fees
    BpiTransactionGas {
        transaction_id: String,
        transaction_type: String,
        gas_amount: Decimal,
    },
    /// PoE mining validation work
    PoEMining {
        mining_session_id: String,
        blocks_validated: u32,
        mining_power: u64,
    },
    /// Network infrastructure provision
    NetworkInfrastructure {
        node_id: String,
        uptime_hours: u32,
        services_provided: Vec<String>,
    },
    /// Governance participation
    GovernanceParticipation {
        proposal_id: String,
        participation_type: GovernanceAction,
        voting_power: u64,
    },
    /// Community validation and notarization
    CommunityValidation {
        validation_id: String,
        items_validated: u32,
        validation_accuracy: Decimal,
    },
}

/// Governance actions that earn coin value
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GovernanceAction {
    Voting,
    ProposalCreation,
    CommunityModeration,
    PolicyReview,
}

/// Work proof with cryptographic verification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkProof {
    /// Unique proof identifier
    pub proof_id: String,
    /// Type of work performed
    pub work_type: WorkType,
    /// Worker identifier (wallet, node, etc.)
    pub worker_id: String,
    /// Fiat value generated by this work
    pub fiat_value_generated: Decimal,
    /// Target coin type for value distribution
    pub target_coin: CoinType,
    /// Cryptographic proof of work completion
    pub cryptographic_proof: String,
    /// Timestamp when work was completed
    pub work_completed_at: DateTime<Utc>,
    /// Verification status
    pub verification_status: VerificationStatus,
    /// Additional metadata
    pub metadata: HashMap<String, String>,
}

/// Work verification status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum VerificationStatus {
    Pending,
    Verified,
    Rejected { reason: String },
    Expired,
}

/// Work proof validation errors
#[derive(Error, Debug)]
pub enum WorkProofError {
    #[error("Invalid work proof: {0}")]
    InvalidWorkProof(String),
    #[error("Work verification failed: {0}")]
    VerificationFailed(String),
    #[error("Insufficient work value: {0}")]
    InsufficientWorkValue(Decimal),
    #[error("Expired work proof: {0}")]
    ExpiredWorkProof(String),
    #[error("Unauthorized coin access: {coin_type:?}")]
    UnauthorizedCoinAccess { coin_type: CoinType },
}

/// Work proof validator ensuring only real work earns coin value
#[derive(Debug)]
pub struct WorkProofValidator {
    /// Minimum work values required for each coin type
    minimum_work_values: HashMap<CoinType, Decimal>,
    /// Maximum work proof age before expiration (hours)
    max_proof_age_hours: u32,
    /// Verified work proofs
    verified_proofs: Vec<WorkProof>,
}

impl WorkProofValidator {
    /// Create new work proof validator
    pub fn new() -> Self {
        let mut minimum_work_values = HashMap::new();
        
        // Set minimum work values (coins must prove real work)
        minimum_work_values.insert(CoinType::Gen, Decimal::new(1, 0));  // $1 minimum for governance
        minimum_work_values.insert(CoinType::Nex, Decimal::new(5, 1));  // $0.5 minimum for mining
        minimum_work_values.insert(CoinType::Flx, Decimal::new(1, 1));  // $0.1 minimum for usage
        minimum_work_values.insert(CoinType::Aur, Decimal::new(10, 0)); // $10 minimum for bank coin
        
        Self {
            minimum_work_values,
            max_proof_age_hours: 24, // 24 hour expiration
            verified_proofs: Vec::new(),
        }
    }
    
    /// Validate work proof and determine coin earning eligibility
    pub fn validate_work_proof(&mut self, mut work_proof: WorkProof) -> Result<WorkProof, WorkProofError> {
        // Check proof age
        let now = Utc::now();
        let proof_age = now.signed_duration_since(work_proof.work_completed_at);
        if proof_age.num_hours() > self.max_proof_age_hours as i64 {
            work_proof.verification_status = VerificationStatus::Expired;
            return Err(WorkProofError::ExpiredWorkProof(work_proof.proof_id));
        }
        
        // Validate minimum work value
        let min_value = self.minimum_work_values.get(&work_proof.target_coin)
            .copied()
            .unwrap_or(Decimal::ZERO);
            
        if work_proof.fiat_value_generated < min_value {
            work_proof.verification_status = VerificationStatus::Rejected {
                reason: format!("Insufficient work value: {} < {}", work_proof.fiat_value_generated, min_value)
            };
            return Err(WorkProofError::InsufficientWorkValue(work_proof.fiat_value_generated));
        }
        
        // Validate work type matches target coin
        self.validate_work_coin_compatibility(&work_proof)?;
        
        // Verify cryptographic proof
        self.verify_cryptographic_proof(&work_proof)?;
        
        // Mark as verified
        work_proof.verification_status = VerificationStatus::Verified;
        
        // Store verified proof
        self.verified_proofs.push(work_proof.clone());
        
        Ok(work_proof)
    }
    
    /// Validate that work type is compatible with target coin
    fn validate_work_coin_compatibility(&self, work_proof: &WorkProof) -> Result<(), WorkProofError> {
        let is_compatible = match (&work_proof.work_type, work_proof.target_coin) {
            // GEN (Mother Coin) - Governance and high-value work
            (WorkType::GovernanceParticipation { .. }, CoinType::Gen) => true,
            (WorkType::NetworkInfrastructure { .. }, CoinType::Gen) => true,
            
            // NEX (Daughter Coin) - PoE mining work
            (WorkType::PoEMining { .. }, CoinType::Nex) => true,
            (WorkType::CommunityValidation { .. }, CoinType::Nex) => true,
            
            // FLX (Daughter Coin) - Network usage work
            (WorkType::BpiRuntimeRent { .. }, CoinType::Flx) => true,
            (WorkType::BpiTransactionGas { .. }, CoinType::Flx) => true,
            (WorkType::NetworkInfrastructure { .. }, CoinType::Flx) => true,
            
            // AUR (Bank Coin) - Restricted to high-value bank work and bank gas transactions
            (WorkType::NetworkInfrastructure { .. }, CoinType::Aur) => true,
            (WorkType::GovernanceParticipation { .. }, CoinType::Aur) => true,
            (WorkType::BpiTransactionGas { .. }, CoinType::Aur) => true, // Allow bank gas transactions
            
            // Cross-compatibility for some work types
            (WorkType::BpiRuntimeRent { .. }, CoinType::Gen) => true, // Rent can earn governance
            (WorkType::PoEMining { .. }, CoinType::Flx) => true,      // Mining can earn usage
            
            _ => false,
        };
        
        if !is_compatible {
            return Err(WorkProofError::InvalidWorkProof(
                format!("Work type {:?} not compatible with coin {:?}", work_proof.work_type, work_proof.target_coin)
            ));
        }
        
        Ok(())
    }
    
    /// Verify cryptographic proof of work
    fn verify_cryptographic_proof(&self, work_proof: &WorkProof) -> Result<(), WorkProofError> {
        // In a real implementation, this would verify cryptographic signatures,
        // blockchain proofs, or other cryptographic evidence of work completion
        
        if work_proof.cryptographic_proof.is_empty() {
            return Err(WorkProofError::VerificationFailed(
                "Missing cryptographic proof".to_string()
            ));
        }
        
        // Simulate cryptographic verification
        if work_proof.cryptographic_proof.len() < 32 {
            return Err(WorkProofError::VerificationFailed(
                "Invalid cryptographic proof format".to_string()
            ));
        }
        
        Ok(())
    }
    
    /// Create work proof for BPI wallet runtime rent
    pub fn create_bpi_rent_proof(
        &self,
        wallet_id: String,
        session_duration_hours: u32,
        rent_rate_per_hour: Decimal,
        target_coin: CoinType,
    ) -> WorkProof {
        let fiat_value = Decimal::from(session_duration_hours) * rent_rate_per_hour;
        
        WorkProof {
            proof_id: format!("rent_{}_{}", wallet_id, Utc::now().timestamp()),
            work_type: WorkType::BpiRuntimeRent {
                wallet_id: wallet_id.clone(),
                session_duration_hours,
                rent_rate_per_hour,
            },
            worker_id: wallet_id.clone(),
            fiat_value_generated: fiat_value,
            target_coin,
            cryptographic_proof: self.generate_rent_proof_signature(&wallet_id, session_duration_hours),
            work_completed_at: Utc::now(),
            verification_status: VerificationStatus::Pending,
            metadata: HashMap::new(),
        }
    }
    
    /// Create work proof for BPI transaction gas
    pub fn create_bpi_gas_proof(
        &self,
        transaction_id: String,
        transaction_type: String,
        gas_amount: Decimal,
        wallet_id: String,
        target_coin: CoinType,
    ) -> WorkProof {
        WorkProof {
            proof_id: format!("gas_{}_{}", transaction_id, Utc::now().timestamp()),
            work_type: WorkType::BpiTransactionGas {
                transaction_id: transaction_id.clone(),
                transaction_type,
                gas_amount,
            },
            worker_id: wallet_id,
            fiat_value_generated: gas_amount,
            target_coin,
            cryptographic_proof: self.generate_gas_proof_signature(&transaction_id, gas_amount),
            work_completed_at: Utc::now(),
            verification_status: VerificationStatus::Pending,
            metadata: HashMap::new(),
        }
    }
    
    /// Create work proof for PoE mining
    pub fn create_poe_mining_proof(
        &self,
        mining_session_id: String,
        blocks_validated: u32,
        mining_power: u64,
        miner_id: String,
        reward_value: Decimal,
    ) -> WorkProof {
        WorkProof {
            proof_id: format!("mining_{}_{}", mining_session_id, Utc::now().timestamp()),
            work_type: WorkType::PoEMining {
                mining_session_id: mining_session_id.clone(),
                blocks_validated,
                mining_power,
            },
            worker_id: miner_id,
            fiat_value_generated: reward_value,
            target_coin: CoinType::Nex, // Mining earns NEX tokens
            cryptographic_proof: self.generate_mining_proof_signature(&mining_session_id, blocks_validated),
            work_completed_at: Utc::now(),
            verification_status: VerificationStatus::Pending,
            metadata: HashMap::new(),
        }
    }
    
    /// Generate cryptographic proof signature for rent
    fn generate_rent_proof_signature(&self, wallet_id: &str, duration: u32) -> String {
        // In real implementation, this would use proper cryptographic signatures
        format!("RENT_PROOF_{}_{}_SIG_{}", wallet_id, duration, Utc::now().timestamp())
    }
    
    /// Generate cryptographic proof signature for gas
    fn generate_gas_proof_signature(&self, transaction_id: &str, gas_amount: Decimal) -> String {
        format!("GAS_PROOF_{}_{}_SIG_{}", transaction_id, gas_amount, Utc::now().timestamp())
    }
    
    /// Generate cryptographic proof signature for mining
    fn generate_mining_proof_signature(&self, session_id: &str, blocks: u32) -> String {
        format!("MINING_PROOF_{}_{}_SIG_{}", session_id, blocks, Utc::now().timestamp())
    }
    
    /// Get verified work proofs
    pub fn get_verified_proofs(&self) -> &[WorkProof] {
        &self.verified_proofs
    }
    
    /// Calculate total work value for a worker
    pub fn calculate_worker_total_value(&self, worker_id: &str) -> Decimal {
        self.verified_proofs
            .iter()
            .filter(|proof| proof.worker_id == worker_id && proof.verification_status == VerificationStatus::Verified)
            .map(|proof| proof.fiat_value_generated)
            .sum()
    }
    
    /// Get work statistics
    pub fn get_work_stats(&self) -> WorkStats {
        let total_proofs = self.verified_proofs.len();
        let verified_proofs = self.verified_proofs
            .iter()
            .filter(|p| p.verification_status == VerificationStatus::Verified)
            .count();
            
        let total_work_value: Decimal = self.verified_proofs
            .iter()
            .filter(|p| p.verification_status == VerificationStatus::Verified)
            .map(|p| p.fiat_value_generated)
            .sum();
            
        WorkStats {
            total_proofs,
            verified_proofs,
            total_work_value,
            average_work_value: if verified_proofs > 0 {
                total_work_value / Decimal::from(verified_proofs)
            } else {
                Decimal::ZERO
            },
        }
    }
}

/// Work statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkStats {
    pub total_proofs: usize,
    pub verified_proofs: usize,
    pub total_work_value: Decimal,
    pub average_work_value: Decimal,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bpi_rent_work_proof() {
        let mut validator = WorkProofValidator::new();
        
        let rent_proof = validator.create_bpi_rent_proof(
            "wallet123".to_string(),
            24, // 24 hours
            Decimal::new(5, 1), // $0.5 per hour
            CoinType::Flx,
        );
        
        assert_eq!(rent_proof.fiat_value_generated, Decimal::from(12)); // 24 * 0.5 = $12
        
        let validated = validator.validate_work_proof(rent_proof).unwrap();
        assert_eq!(validated.verification_status, VerificationStatus::Verified);
    }
    
    #[test]
    fn test_insufficient_work_value() {
        let mut validator = WorkProofValidator::new();
        
        let low_value_proof = validator.create_bpi_rent_proof(
            "wallet123".to_string(),
            1, // 1 hour
            Decimal::new(5, 2), // $0.05 per hour (too low)
            CoinType::Flx,
        );
        
        let result = validator.validate_work_proof(low_value_proof);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_work_coin_compatibility() {
        let mut validator = WorkProofValidator::new();
        
        // Mining work should be compatible with NEX coin
        let mining_proof = validator.create_poe_mining_proof(
            "session123".to_string(),
            10, // blocks
            1000, // mining power
            "miner456".to_string(),
            Decimal::from(25), // $25 reward
        );
        
        let validated = validator.validate_work_proof(mining_proof).unwrap();
        assert_eq!(validated.verification_status, VerificationStatus::Verified);
        assert_eq!(validated.target_coin, CoinType::Nex);
    }
    
    #[test]
    fn test_zero_value_start() {
        let validator = WorkProofValidator::new();
        
        // All coins should require minimum work value > 0
        for coin_type in [CoinType::Gen, CoinType::Nex, CoinType::Flx, CoinType::Aur] {
            let min_value = validator.minimum_work_values.get(&coin_type).unwrap();
            assert!(*min_value > Decimal::ZERO, "Coin {:?} should require work to earn value", coin_type);
        }
    }
}
