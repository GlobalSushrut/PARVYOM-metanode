//! # StepReceipt - Container Operation Receipts
//!
//! Implements the v1.0 blueprint StepReceipt structure for every container operation.
//! These receipts are generated by DockLock and sent to ENC-notary for LogBlock aggregation.

use crate::error::{DockLockError, DockLockResult};
use blake3::Hasher;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};
use tracing::{debug, info};

/// StepReceipt - Generated by DockLock for every container operation
/// Follows v1.0 blueprint specification exactly
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StepReceipt {
    /// Version (always 1 for v1.0)
    pub v: u8,
    /// Application identifier
    pub app: String,
    /// Container identifier
    pub container: String,
    /// Operation type (exec.start, exec.stop, io.read, io.write, etc.)
    pub op: String,
    /// ISO 8601 timestamp
    pub ts: String,
    /// Resource usage metrics for billing and PoE calculation
    pub usage: ResourceUsage,
    /// Labels for policy enforcement and routing
    pub labels: HashMap<String, String>,
    /// Previous receipt hash (blake3:...)
    pub prev_hash: String,
    /// Current receipt hash (blake3:...)
    pub hash: String,
    /// Ed25519 signature (ed25519:...)
    pub sig: String,
}

/// Resource usage metrics for billing and PoE calculation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceUsage {
    /// CPU time in milliseconds
    pub cpu_ms: u64,
    /// Memory usage in MB-seconds
    pub memory_mb_s: u64,
    /// Storage usage in GB-days
    pub storage_gb_day: f64,
    /// Network egress in MB
    pub egress_mb: f64,
    /// Number of receipts (for audit incentives)
    pub receipts_count: u64,
}

/// StepReceipt generator for container operations
pub struct StepReceiptGenerator {
    /// Ed25519 signing key for receipts
    signing_key: SigningKey,
    /// Verifying key (public key)
    verifying_key: VerifyingKey,
    /// Application identifier
    app_id: String,
    /// Last receipt hash for chaining
    last_hash: Option<String>,
}

impl StepReceiptGenerator {
    /// Create a new StepReceipt generator
    pub fn new(app_id: String, signing_key: SigningKey) -> Self {
        let verifying_key = VerifyingKey::from(&signing_key);
        Self {
            signing_key,
            verifying_key,
            app_id,
            last_hash: None,
        }
    }

    /// Generate a StepReceipt for a container operation
    pub fn generate_receipt(
        &mut self,
        container_id: String,
        operation: String,
        usage: ResourceUsage,
        labels: HashMap<String, String>,
    ) -> DockLockResult<StepReceipt> {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| DockLockError::SystemError(format!("Time error: {}", e)))?;
        
        let ts = chrono::DateTime::from_timestamp(timestamp.as_secs() as i64, 0)
            .ok_or_else(|| DockLockError::SystemError("Invalid timestamp".to_string()))?
            .format("%Y-%m-%dT%H:%M:%SZ")
            .to_string();

        let prev_hash = self.last_hash.clone().unwrap_or_else(|| "blake3:genesis".to_string());

        // Create receipt without hash and signature first
        let mut receipt = StepReceipt {
            v: 1,
            app: self.app_id.clone(),
            container: container_id,
            op: operation,
            ts,
            usage,
            labels,
            prev_hash,
            hash: String::new(), // Will be computed
            sig: String::new(),  // Will be computed
        };

        // Compute hash
        let hash = self.compute_receipt_hash(&receipt)?;
        receipt.hash = format!("blake3:{}", hex::encode(hash));

        // Sign the receipt
        let signature = self.signing_key.sign(&hash);
        receipt.sig = format!("ed25519:{}", hex::encode(signature.to_bytes()));

        // Update last hash for chaining
        self.last_hash = Some(receipt.hash.clone());

        info!("Generated StepReceipt: app={}, container={}, op={}", 
              receipt.app, receipt.container, receipt.op);

        Ok(receipt)
    }

    /// Compute Blake3 hash of receipt for signing
    fn compute_receipt_hash(&self, receipt: &StepReceipt) -> DockLockResult<[u8; 32]> {
        let mut hasher = Hasher::new();
        
        // Hash all fields except hash and sig
        hasher.update(&receipt.v.to_le_bytes());
        hasher.update(receipt.app.as_bytes());
        hasher.update(receipt.container.as_bytes());
        hasher.update(receipt.op.as_bytes());
        hasher.update(receipt.ts.as_bytes());
        
        // Hash usage
        hasher.update(&receipt.usage.cpu_ms.to_le_bytes());
        hasher.update(&receipt.usage.memory_mb_s.to_le_bytes());
        hasher.update(&receipt.usage.storage_gb_day.to_le_bytes());
        hasher.update(&receipt.usage.egress_mb.to_le_bytes());
        hasher.update(&receipt.usage.receipts_count.to_le_bytes());
        
        // Hash labels (sorted for determinism)
        let mut label_keys: Vec<_> = receipt.labels.keys().collect();
        label_keys.sort();
        for key in label_keys {
            hasher.update(key.as_bytes());
            hasher.update(receipt.labels[key].as_bytes());
        }
        
        hasher.update(receipt.prev_hash.as_bytes());
        
        Ok(*hasher.finalize().as_bytes())
    }

    /// Verify a StepReceipt signature
    pub fn verify_receipt(&self, receipt: &StepReceipt) -> DockLockResult<bool> {
        // Extract signature
        let sig_hex = receipt.sig.strip_prefix("ed25519:")
            .ok_or_else(|| DockLockError::ValidationError("Invalid signature format".to_string()))?;
        
        let sig_bytes = hex::decode(sig_hex)
            .map_err(|e| DockLockError::ValidationError(format!("Invalid signature hex: {}", e)))?;
        
        let signature = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| 
            DockLockError::ValidationError("Invalid signature length".to_string()))?);

        // Recompute hash
        let hash = self.compute_receipt_hash(receipt)?;

        // Verify signature
        match self.verifying_key.verify(&hash, &signature) {
            Ok(()) => Ok(true),
            Err(_) => Ok(false),
        }
    }
}

impl ResourceUsage {
    /// Create new ResourceUsage with zero values
    pub fn new() -> Self {
        Self {
            cpu_ms: 0,
            memory_mb_s: 0,
            storage_gb_day: 0.0,
            egress_mb: 0.0,
            receipts_count: 1, // Always count this receipt
        }
    }

    /// Add CPU usage in milliseconds
    pub fn add_cpu_ms(&mut self, cpu_ms: u64) {
        self.cpu_ms += cpu_ms;
    }

    /// Add memory usage in MB-seconds
    pub fn add_memory_mb_s(&mut self, memory_mb_s: u64) {
        self.memory_mb_s += memory_mb_s;
    }

    /// Add storage usage in GB-days
    pub fn add_storage_gb_day(&mut self, storage_gb_day: f64) {
        self.storage_gb_day += storage_gb_day;
    }

    /// Add network egress in MB
    pub fn add_egress_mb(&mut self, egress_mb: f64) {
        self.egress_mb += egress_mb;
    }

    /// Get total usage for PoE calculation
    pub fn total_usage(&self) -> f64 {
        self.cpu_ms as f64 + self.memory_mb_s as f64 + self.storage_gb_day + self.egress_mb
    }
}

impl Default for ResourceUsage {
    fn default() -> Self {
        Self::new()
    }
}

impl StepReceipt {
    /// Convert to JSON for transmission
    pub fn to_json(&self) -> DockLockResult<String> {
        serde_json::to_string(self)
            .map_err(|e| DockLockError::SerializationError(format!("JSON serialization failed: {}", e)))
    }

    /// Parse from JSON
    pub fn from_json(json: &str) -> DockLockResult<Self> {
        serde_json::from_str(json)
            .map_err(|e| DockLockError::SerializationError(format!("JSON deserialization failed: {}", e)))
    }

    /// Check if receipt is valid (basic validation)
    pub fn is_valid(&self) -> bool {
        self.v == 1 &&
        !self.app.is_empty() &&
        !self.container.is_empty() &&
        !self.op.is_empty() &&
        !self.ts.is_empty() &&
        self.hash.starts_with("blake3:") &&
        self.sig.starts_with("ed25519:")
    }

    /// Get receipt age in seconds
    pub fn age_seconds(&self) -> Option<u64> {
        chrono::DateTime::parse_from_rfc3339(&self.ts).ok()
            .and_then(|dt| {
                let now = chrono::Utc::now();
                let duration = now.signed_duration_since(dt);
                if duration.num_seconds() >= 0 {
                    Some(duration.num_seconds() as u64)
                } else {
                    None
                }
            })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::SigningKey;
    use rand::rngs::OsRng;

    fn create_test_generator() -> StepReceiptGenerator {
        let mut csprng = OsRng;
        let signing_key = SigningKey::generate(&mut csprng);
        StepReceiptGenerator::new("TEST_APP".to_string(), signing_key)
    }

    #[test]
    fn test_step_receipt_generation() {
        let mut generator = create_test_generator();
        
        let usage = ResourceUsage {
            cpu_ms: 412,
            memory_mb_s: 265,
            storage_gb_day: 0.1,
            egress_mb: 1.2,
            receipts_count: 1,
        };

        let mut labels = HashMap::new();
        labels.insert("pii".to_string(), "false".to_string());
        labels.insert("region".to_string(), "ca-east".to_string());

        let receipt = generator.generate_receipt(
            "job-9812".to_string(),
            "exec.start".to_string(),
            usage,
            labels,
        ).unwrap();

        assert_eq!(receipt.v, 1);
        assert_eq!(receipt.app, "TEST_APP");
        assert_eq!(receipt.container, "job-9812");
        assert_eq!(receipt.op, "exec.start");
        assert!(receipt.hash.starts_with("blake3:"));
        assert!(receipt.sig.starts_with("ed25519:"));
        assert!(receipt.is_valid());
    }

    #[test]
    fn test_receipt_verification() {
        let mut generator = create_test_generator();
        
        let usage = ResourceUsage::new();
        let labels = HashMap::new();

        let receipt = generator.generate_receipt(
            "test-container".to_string(),
            "test-op".to_string(),
            usage,
            labels,
        ).unwrap();

        assert!(generator.verify_receipt(&receipt).unwrap());
    }

    #[test]
    fn test_receipt_chaining() {
        let mut generator = create_test_generator();
        
        let usage = ResourceUsage::new();
        let labels = HashMap::new();

        let receipt1 = generator.generate_receipt(
            "container1".to_string(),
            "op1".to_string(),
            usage.clone(),
            labels.clone(),
        ).unwrap();

        let receipt2 = generator.generate_receipt(
            "container2".to_string(),
            "op2".to_string(),
            usage,
            labels,
        ).unwrap();

        assert_eq!(receipt2.prev_hash, receipt1.hash);
    }

    #[test]
    fn test_resource_usage() {
        let mut usage = ResourceUsage::new();
        usage.add_cpu_ms(100);
        usage.add_memory_mb_s(50);
        usage.add_storage_gb_day(0.5);
        usage.add_egress_mb(2.0);

        assert_eq!(usage.cpu_ms, 100);
        assert_eq!(usage.memory_mb_s, 50);
        assert_eq!(usage.storage_gb_day, 0.5);
        assert_eq!(usage.egress_mb, 2.0);
        assert_eq!(usage.receipts_count, 1);
    }
}
